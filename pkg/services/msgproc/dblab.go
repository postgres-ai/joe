/*
2019 © Postgres.ai
*/

// Package msgproc provides a service for processing of incoming events.
package msgproc

import (
	"context"
	"strings"
	"time"

	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/pkg/errors"
	"github.com/rs/xid"
	"github.com/sethvargo/go-password/password"

	"gitlab.com/postgres-ai/database-lab/v2/pkg/client/dblabapi/types"
	"gitlab.com/postgres-ai/database-lab/v2/pkg/log"
	dblabmodels "gitlab.com/postgres-ai/database-lab/v2/pkg/models"

	"gitlab.com/postgres-ai/joe/pkg/foreword"
	"gitlab.com/postgres-ai/joe/pkg/models"
	"gitlab.com/postgres-ai/joe/pkg/services/platform"
	"gitlab.com/postgres-ai/joe/pkg/services/usermanager"
	"gitlab.com/postgres-ai/joe/pkg/util"
)

// HelpMessage defines available commands provided with the help message.
const HelpMessage = "\n• `explain` — analyze your query (SELECT, INSERT, DELETE, UPDATE or WITH) and generate recommendations\n" +
	"• `plan` — analyze your query (SELECT, INSERT, DELETE, UPDATE or WITH) without execution\n" +
	"• `exec` — execute any query (for example, CREATE INDEX)\n" +
	"• `activity` — show currently running sessions in Postgres (states: `active`, `idle in transaction`, `disabled`)\n" +
	"• `terminate [pid]` — terminate Postgres backend that has the specified PID.\n" +
	"• `reset` — revert the database to the initial state (usually takes less than a minute, :warning: all changes will be lost)\n" +
	"• `\\d`, `\\d+`, `\\dt`, `\\dt+`, `\\di`, `\\di+`, `\\l`, `\\l+`, `\\dv`, `\\dv+`, `\\dm`, `\\dm+` — psql meta information commands\n" +
	"• `hypo` — create hypothetical indexes using the HypoPG extension\n" +
	"• `help` — this message\n\n" +
	"• Sessions are fully independent. Feel free to do anything.\n" +
	"• The session will be destroyed after the certain amount of time ('idle timeout') of inactivity.\n" +
	"• EXPLAIN plans here are expected to be identical to production plans.\n" +
	"• The actual timing values may differ from production because actual caches in DB Lab are smaller. " +
	"However, the number of bytes and pages/buffers in plans match the production database.\n"

// MsgSessionStarting provides a message for a session start.
const MsgSessionStarting = "Starting a new session..."

// SeparatorEllipsis provides a separator for cut messages.
const SeparatorEllipsis = "\n[...SKIP...]\n"

// QueryPreviewSize defines a max preview size of query in message.
const QueryPreviewSize = 400

// Hint messages.
const (
	HintExplain = "Consider using `explain` command for DML statements. See `help` for details."
	HintExec    = "Consider using `exec` command for DDL statements. See `help` for details."
)

const (
	joeUserNamePrefix = "joe_"
	joeSessionPrefix  = "joe-"
)

// Constants for autogenerated passwords.
const (
	PasswordLength     = 16
	PasswordMinDigits  = 4
	PasswordMinSymbols = 0
)

// Database connection configuration options.
const (
	maxConnLifetime = 0
	maxConnIdleTime = 480 * time.Minute
)

// runSession starts a user session if not exists.
func (s *ProcessingService) runSession(ctx context.Context, user *usermanager.User, incomingMessage models.IncomingMessage) (err error) {
	sMsg := models.NewMessage(incomingMessage)

	if user.Session.Clone != nil {
		return nil
	}

	// Stop clone session if not active.
	s.stopSession(ctx, user)

	messageText := strings.Builder{}

	messageText.WriteString(MsgSessionStarting)
	sMsg.SetText(messageText.String())
	s.messenger.Publish(sMsg)
	messageText.Reset()

	s.messenger.UpdateStatus(sMsg, models.StatusRunning)

	sessionID := generateSessionID()
	if incomingMessage.SessionID != "" {
		sessionID = incomingMessage.SessionID
	}

	user.Session.PlatformSessionID = sessionID

	defer func() {
		if err != nil {
			if failErr := s.messenger.Fail(sMsg, err.Error()); failErr != nil {
				log.Err(failErr)
			}
		}
	}()

	clone, err := s.createDBLabClone(ctx, user, sessionID)
	if err != nil {
		return errors.Wrap(err, "failed to create a Database Lab clone")
	}

	fwData := &foreword.Content{
		SessionID:  sessionID,
		Duration:   time.Duration(clone.Metadata.MaxIdleMinutes) * time.Minute,
		AppVersion: s.config.App.Version,
		Edition:    s.featurePack.Entertainer().GetEdition(),
		DBName:     s.config.DBLab.DBName,
		DSA:        clone.Snapshot.DataStateAt,
		DBSize:     util.NA,
		DSADiff:    "-",
	}

	dblabClone := s.buildDBLabCloneConn(clone.DB)

	db, userConn, err := initConn(ctx, dblabClone)
	if err != nil {
		return errors.Wrap(err, "failed to init database connection")
	}

	if err := fwData.EnrichForewordInfo(ctx, db); err != nil {
		return err
	}

	user.Session.ConnParams = dblabClone
	user.Session.Clone = clone
	user.Session.Pool = db
	user.Session.CloneConnection = userConn
	user.Session.LastActionTs = time.Now()
	user.Session.ChannelID = incomingMessage.ChannelID

	if s.config.Platform.HistoryEnabled && incomingMessage.SessionID == "" {
		if err := s.createPlatformSession(ctx, user, sMsg.ChannelID); err != nil {
			return errors.Wrap(err, "failed to create a platform session")
		}
	}

	sMsg.AppendText(fwData.GetForeword())

	if err := s.messenger.UpdateText(sMsg); err != nil {
		return errors.Wrap(err, "failed to append message with foreword")
	}

	if err := s.messenger.OK(sMsg); err != nil {
		log.Err(err)
	}

	return nil
}

func (s *ProcessingService) buildDBLabCloneConn(dbParams dblabmodels.Database) models.Clone {
	return models.Clone{
		Name:     s.config.DBLab.DBName,
		Host:     dbParams.Host,
		Port:     dbParams.Port,
		Username: dbParams.Username,
		Password: dbParams.Password,
		SSLMode:  s.config.DBLab.SSLMode,
	}
}

func initConn(ctx context.Context, dblabClone models.Clone) (*pgxpool.Pool, *pgx.Conn, error) {
	connectionConfig, err := pgxpool.ParseConfig(dblabClone.ConnectionString())
	if err != nil {
		log.Err("Failed to parse connection config:", err)
		return nil, nil, err
	}

	connectionConfig.MaxConnLifetime = maxConnLifetime
	connectionConfig.MaxConnIdleTime = maxConnIdleTime

	pool, err := pgxpool.ConnectConfig(context.Background(), connectionConfig)
	if err != nil {
		log.Err("Failed to init connection:", err)
		return nil, nil, err
	}

	connection, err := pool.Acquire(ctx)
	if err != nil {
		log.Err("Failed to acquire user connection:", err)
		return nil, nil, err
	}

	return pool, connection.Conn(), nil
}

// createDBLabClone creates a new clone.
func (s *ProcessingService) createDBLabClone(ctx context.Context, user *usermanager.User, sessionID string) (*dblabmodels.Clone, error) {
	pwd, err := password.Generate(PasswordLength, PasswordMinDigits, PasswordMinSymbols, false, true)
	if err != nil {
		return nil, errors.Wrap(err, "failed to generate a password to a new clone")
	}

	clientRequest := types.CloneCreateRequest{
		ID:        sessionID,
		Protected: false,
		DB: &types.DatabaseRequest{
			Username:   joeUserNamePrefix + user.UserInfo.Name,
			Password:   pwd,
			Restricted: true,
			DBName:     s.config.DBLab.DBName,
		},
	}

	clone, err := s.DBLab.CreateClone(ctx, clientRequest)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create a new clone")
	}

	if clone.Snapshot == nil {
		clone.Snapshot = &dblabmodels.Snapshot{}
	}

	clone.DB.Password = pwd

	// To get an accessible address in case running the assistant inside a container.
	if clone.DB.Host == "localhost" || clone.DB.Host == "127.0.0.1" {
		clone.DB.Host = s.DBLab.URL("").Hostname()
	}

	return clone, nil
}

// createPlatformSession starts a new platform session.
func (s *ProcessingService) createPlatformSession(ctx context.Context, user *usermanager.User, channelID string) error {
	platformSession := platform.Session{
		UserID:      user.UserInfo.ID,
		Username:    user.UserInfo.Name,
		ChannelID:   channelID,
		ProjectName: s.config.Project,
	}

	sessionID, err := s.platformManager.CreatePlatformSession(ctx, platformSession)
	if err != nil {
		log.Err("API: Create platform session:", err)

		if err := s.destroySession(ctx, user); err != nil {
			return errors.Wrap(err, "failed to stop a user session")
		}

		return errors.Wrap(err, "failed to create a platform session")
	}

	user.Session.PlatformSessionID = sessionID

	return nil
}

// generateSessionID generates a session ID for Joe.
func generateSessionID() string {
	return joeSessionPrefix + xid.New().String()
}
